using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;




enum FuelType
{
    Diesel,
    Petrol
};

public class DefaultEngine : MonoBehaviour
{
    [Header("Engine Properties")]

    //The amount of cylinders the engine has, minimum of 1, maximum of 20, used to calculate final engine power
    [Tooltip("[Warning!] Increasing Cylinders and Cylinder Displacement too far with a light ship will cause flipping!")]
    [Range(1, 20)]
    [SerializeField] int cylinders;

    //The displacement (volume of aerosolised fuel) of each engine cylinder, used to calculate final engine power
    [Tooltip("[Warning!] Increasing Cylinders and Cylinder Displacement too far with a light ship will cause flipping!")]
    [Range(1, 20f)]
    [SerializeField] float cylinderDisplacement;

    [Tooltip("The total engine displacement, calculated by multiplying the cylinder displacement by the number of cylinders")]
    [SerializeField] float engineDisplacement;

    [Tooltip("The Rotations Per Minute of the engine, used to calculate the current engine power")]
    [Range(0, 5000)]
    [SerializeField] int RPM;

    [Tooltip("The amount of fuel being used by the engine currently. Used to check if enough fuel is available to use")]
    [SerializeField] float fuelUsage;

    [Tooltip("The fuel type used by the engine, defaults are Diesel or Petrol")]
    [SerializeField] FuelType engineFuelType;

    [Tooltip("The type of fuel that's being used and its properties (Name, Specific Energy, and Energy Density)")]
    [SerializeField] Fuel fuelType;//The fuel type struct that will contain all the relevant details about the fuel for this engine.

    [Tooltip("Is there any fuel available, if not force off the ignition")]
    [SerializeField] bool fuelAvailable = true;

    [Tooltip("The current engine throttle being set by the Ship Controller Script")]
    [SerializeField] float throttle;

    [Tooltip("Engine ignition, engine will not produce power if this is off")]
    [SerializeField] bool ignition = false;


    [Header("Propeller Properties")]

    [Tooltip("The size of the propeller. Will affect how much thrust is actually applied to the boat")]
    [SerializeField] float propellerSize;

    [Tooltip("The current resistance generated because of the water against the propeller. " +
        "This will affect how quick the RPM will climb")]
    [SerializeField] float resistance;//The resistance of the propeller, this will affect how quick the RPM will climb


    [Header("Propulsion Properties")]

    [Tooltip("The propulsion/thrust being generated by the engine after taking into consideration" +
        "throttle, RPM, fuel type, resistance, and engine displacement")]
    [SerializeField] float propulsionForce;

    [Tooltip("If the engine is below water then apply thrust, otherwise next to no thrust is generated.")]
    [SerializeField] bool isBelowWater;

    [Tooltip("The Ship Controller Script attached to the boat this engine is attached to")]
    [SerializeField] ShipControllerScript shipController;

    [Tooltip("The Engine Controller script that is attached to the boat this engine is attached to")]
    [SerializeField] EngineController engineController;

    [Tooltip("The Water Control script that is used in the current unity scene")]
    [SerializeField] WaterControlScript waterControlScript;

    /// <summary>
    /// The delay between each request for more fuel. Too low and the fuel will rapidly drain,
    /// to high and fuel will last too long
    /// </summary>
    float engineUseFuelTime = 1.0f;

    /// <summary>
    /// Used to track how long it's been since the last fuel request
    /// </summary>
    float timer = 0.0f;

    // Start is called before the first frame update
    void Start()
    {
        switch (engineFuelType)
        {
            case FuelType.Diesel:
                fuelType = EngineController.Diesel;//Specific Energy = 45.6, Energy Density = 38.6
                break;
            case FuelType.Petrol:
                fuelType = EngineController.Petrol;//Specific Energy = 46.4, Energy Density = 34.3
                break;
        }
        shipController = gameObject.transform.parent.parent.gameObject.GetComponent<ShipControllerScript>();
        engineController = gameObject.transform.parent.gameObject.GetComponent<EngineController>();
        waterControlScript = GameObject.Find("waterPlane").GetComponent<WaterControlScript>();

        engineDisplacement = cylinderDisplacement * cylinders;

        RPM = 0;
    }

    // Update is called once per frame
    void Update()
    {
        //Check if the propulsion object is below the water.
        checkIsBelowWater();

        timer += Time.deltaTime;
        timer = timer > 1.0f ? 1.0f : timer;

        resistance = waterControlScript.density / propellerSize * (1.0f - waterControlScript.dynamicViscosity) * shipController.getSpeed();
        throttle = shipController.getCurrentThrottle();

        if (!shipController)
        {
            shipController = gameObject.transform.parent.parent.gameObject.GetComponent<ShipControllerScript>();
        }
        else if (shipController.getIgnition())
        {
            //Check if it's been long enough to collect fuel again
            if (timer >= engineUseFuelTime)
            {
                fuelAvailable = engineController.requestFuel(fuelUsage);
                timer = 0.0f;
            }
            
            if (fuelAvailable)
            {
                ignition = true;
                if (RPM < (int)Mathf.Lerp(0, 5000.0f, throttle / 100) && ignition)
                {
                    RPM += (int)throttle - (int)(RPM / resistance)/10;
                }
                else if (RPM > (int)Mathf.Lerp(0, 5000.0f, throttle / 100) && ignition)
                {
                    RPM -= (int)throttle - (int)(throttle * resistance);
                }
                if (RPM > 5000 && ignition)
                {
                   RPM = 5000;
                }
                else if (RPM < -0)
                {
                    RPM = 0;
                }


                propulsionForce = calculateHorsePower(cylinders, cylinderDisplacement, RPM, fuelType);

                fuelUsage = calculateFuelUsage();
            }
            else
            {
                ignition = false;
                RPM -= 100;
                if (RPM < -0)
                {
                    RPM = 0;
                }
            }
            
        }
        else if (!shipController.getIgnition() || !fuelAvailable)
        {
            //Either the engine is off or there's no fuel left!
            if (RPM > 0)
            {
                RPM -= 100;
            }

            fuelUsage = 0;
        }

        
    }

    /// <summary>
    /// Calculates the horse power / propulsion force of the engine using the cylinders, RPM, and fuel type used
    /// </summary>
    /// <param name="cylinders">How many cylinders the engine has</param>
    /// <param name="cylinderDisplacement">The displacement of the cylinders</param>
    /// <param name="RPM">The current engine RPM</param>
    /// <param name="fuelType">The fule type being used by the engine</param>
    /// <returns>The horse power / propulsion force of the engine</returns>
    float calculateHorsePower(int cylinders, float cylinderDisplacement, int RPM, Fuel fuelType)
    {
        float result;

        result = ((fuelType.energyDensity * (cylinderDisplacement * cylinders)) * RPM) / 5252;

        return result;
    }

    /// <summary>
    /// Checks if the engine is below water. If it is the engine can generate full power,
    /// otherwise it generates barely any power
    /// </summary>
    void checkIsBelowWater()
    {
        FloatingScript floatingScript = gameObject.transform.parent.parent.GetComponent<FloatingScript>();

        var meshFilter = GetComponent<MeshFilter>();

        var list = meshFilter.mesh.vertices.Select(transform.TransformPoint).OrderBy(v => v.y).ToList();


        if (list[0].y < floatingScript.getClosestVertexOfWater(GameObject.Find("waterPlane"), list[0]).y)
        {
            isBelowWater = true;
        }
        else
        {
            isBelowWater = false;
        }
    }

    /// <summary>
    /// Calculates the current fuel useage based on the engines total displacementand RPM, 
    /// uses the volume of an aerosolised liqued to get an accurate fuel usage.
    /// </summary>
    /// <returns>Fuel used this fuel usage cycle</returns>
    float calculateFuelUsage()
    {
        return (engineDisplacement * (RPM/5000)) * 0.06f;
    }

    /// <summary>
    /// Returns the engines current horse power / propulsion force so other scripts can access this value
    /// </summary>
    /// <returns>Current horse power / propulsion force of this engine</returns>
    public float getHorsePower()
    {
        return propulsionForce;
    }

    /// <summary>
    /// Returns whether this engine is currently submerged or not
    /// </summary>
    /// <returns>The engines current submerged status</returns>
    public bool getIsBelowWater()
    {
        return isBelowWater;
    }

    /// <summary>
    /// Returns the status of this engines ignition
    /// </summary>
    /// <returns>This engines ignition status</returns>
    public bool getIgnition()
    {
        return ignition;
    }
}
